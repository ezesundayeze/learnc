<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 9  Interacting with the System (Days 27-29)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
        }
        h1, h2 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            margin-bottom: 10px;
        }
        a {
            text-decoration: none;
            color: #0366d6;
            font-size: 1.1em;
        }
        a:hover {
            text-decoration: underline;
        }
        .module-link {
            display: block;
            padding: 10px 15px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        .module-link:hover {
            background-color: #f0f2f5;
            text-decoration: none;
        }
        .bonus-module {
            margin-top: 30px;
            border-top: 2px solid #eee;
            padding-top: 20px;
        }

        .content {
            animation: fadeIn 1s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        body > .content {
            padding: 20px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #f6f8fa;
        }
        pre {
            background-color: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="content">
        <a href="../index.html">&larr; Back to Home</a>
        <hr>
        <h1>Module 9: Interacting with the System (Days 27-29)</h1>

<h2>1. Philosophy Focus: Knowledge Graph &amp; Done-for-you Training Plan</h2>

<p>You've built a robust, dynamic, and modular application. The next
logical question is, "How do I save my data?" This module directly
answers that by introducing file I/O, connecting your knowledge of
pointers and structs to the file system. We then introduce command-line
arguments, a professional feature that makes your application more
flexible and powerful.</p>

<h3><strong>DAY 27: Reading From and Writing To Files</strong></h3>

<p><strong>Goal:</strong> Learn the fundamental C functions for file manipulation.</p>

<p>1. The FILE Pointer</p>

<p>In C, you interact with files through a special kind of pointer: FILE
*. Think of it as a handle that keeps track of which file you're
working with, where you are in the file, etc. You get this pointer by
calling fopen().</p>

<p><strong>2. The Core Functions: fopen, fprintf, fscanf, fclose</strong></p>

<ul>
<li><p>fopen("filename.txt", "mode"): Opens a file. The "mode" is a</p>

<blockquote>
  <p>string that specifies what you want to do. Common modes are:</p>
</blockquote>

<ul>
<li><p>"r": Read (file must exist).</p></li>
<li><p>"w": Write (creates a new file, or <strong>erases</strong> an existing</p>

<blockquote>
  <p>file).</p>
</blockquote></li>
<li><p>"a": Append (adds to the end of an existing file, or creates</p>

<blockquote>
  <p>it if it doesn't exist).</p>
</blockquote></li>
<li><p>It returns a FILE * on success or NULL on failure. **Always</p>

<blockquote>
  <p>check for NULL!**</p>
</blockquote></li>
</ul></li>
<li><p>fprintf(file_ptr, "format string", ...): Just like printf, but it</p>

<blockquote>
  <p>writes to a file instead of the console.</p>
</blockquote></li>
<li><p>fscanf(file_ptr, "format string", ...): Just like scanf, but it</p>

<blockquote>
  <p>reads from a file.</p>
</blockquote></li>
<li><p>fclose(file_ptr): Closes the file, releasing the handle. For every</p>

<blockquote>
  <p>successful fopen, you <strong>must</strong> have a matching fclose to prevent
  resource leaks.</p>
</blockquote></li>
</ul>

<p><strong>Inductive Example:</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
FILE *outfile = fopen("hello.txt", "w"); // Open for writing

if (outfile == NULL) {
printf("Error: Could not open file for writing.\n");
return 1;
}

fprintf(outfile, "Hello, C Files!\n");
fprintf(outfile, "This is line %d.\n", 2);
fclose(outfile); // Close it
printf("Wrote data to hello.txt\n");

// --- Now, let's read it back ---

FILE *infile = fopen("hello.txt", "r"); // Open for reading
if (infile == NULL) {
printf("Error: Could not open file for reading.\n");
return 1;
}

char line1[100];
char line2[100];
int number;

// Read the first line
fgets(line1, sizeof(line1), infile);
// fgets is often safer than fscanf for whole lines

// Read the formatted second line
fscanf(infile, "This is line %d.\n", &amp;number);

fclose(infile);

printf("\nRead from file:\n");
printf("Line 1: %s", line1); // fgets includes the newline
printf("Number from Line 2: %d\n", number);

return 0;
}
</code></pre>

<p><strong>3. Day 27 Practice</strong></p>

<ol>
<li><p><strong>Journal Writer:</strong> Write a program that asks the user for a journal</p>

<blockquote>
  <p>entry. Open a file named journal.txt in append mode ("a"). Write
  the user's entry to the file, followed by a newline. Run the
  program multiple times to see your journal grow.</p>
</blockquote></li>
<li><p><strong>Journal Reader:</strong> Write a separate program that opens journal.txt</p>

<blockquote>
  <p>for reading ("r") and prints its entire contents to the console.</p>
</blockquote></li>
</ol>

<h3><strong>DAY 28: Making the To-Do List Persistent</strong></h3>

<p><strong>Goal:</strong> Integrate file I/O into your main project to save and load
your task list.</p>

<p><strong>1. The Strategy</strong></p>

<ul>
<li><p><strong>Saving:</strong> When the program is about to exit, we'll open a file</p>

<blockquote>
  <p>(e.g., tasks.csv) in write mode ("w"). We'll loop through our
  array of tasks and fprintf each one to the file in a structured
  way. A "comma-separated value" (CSV) format is simple and
  effective: id,completed,description.</p>
</blockquote></li>
<li><p><strong>Loading:</strong> When the program first starts, we'll check if</p>

<blockquote>
  <p>tasks.csv exists and try to open it in read mode ("r"). We'll
  read the file line by line, parse the data, and dynamically add
  each task to our list, realloc-ing as needed.</p>
</blockquote></li>
</ul>

<p><strong>2. Day 28 Practice: Project Upgrade</strong></p>

<ol>
<li><p><strong>Create save_tasks function:</strong></p>

<ul>
<li><p>In task.h, add the prototype: void save_tasks(const char</p>

<blockquote>
  <p>*filename, struct Task list[], int count);</p>
</blockquote></li>
<li><p>In task.c, implement the function. It should fopen the file in</p>

<blockquote>
  <p>"w" mode. Loop from 0 to count and use fprintf to write each
  task's id, completed status, and description to the file,
  separated by commas, with a newline at the end. Don't forget
  to fclose.</p>
</blockquote></li>
</ul></li>
<li><p><strong>Create load_tasks function:</strong></p>

<ul>
<li><p>This is more challenging. The prototype in task.h will be tricky</p>

<blockquote>
  <p>because it needs to modify your main list variables: int
  load<em>tasks(const char *filename, struct Task **list</em>ptr,
  int *count<em>ptr, int *capacity</em>ptr);</p>
</blockquote></li>
<li><p>In task.c, implement it. fopen the file in "r" mode. If it</p>

<blockquote>
  <p>fails (e.g., file doesn't exist), that's fine; just return
  0.</p>
</blockquote></li>
<li><p>If it opens, read the file line-by-line using fgets. For each</p>

<blockquote>
  <p>line:</p>
</blockquote>

<ul>
<li><p>You need to parse it. sscanf(line, "%d,%d,%[^\n]",</p>

<blockquote>
  <p>&amp;id, &amp;completed, desc_buffer); is a good way to parse a
  CSV line. The %[^\n] part means "read every character
  until you hit a newline".</p>
</blockquote></li>
<li><p>Once parsed, you have the data for a new task. Use your</p>

<blockquote>
  <p>add_task logic (checking capacity, reallocating, etc.) to
  add this loaded task to the list.</p>
</blockquote></li>
</ul></li>
<li><p>Return the number of tasks loaded.</p></li>
</ul></li>
<li><p><strong>Integrate into main.c:</strong></p>

<ul>
<li><p>At the very beginning of main, call load_tasks(...).</p></li>
<li><p>Just before the return 0; at the end of main, call</p>

<blockquote>
  <p>save_tasks(...).</p>
</blockquote></li>
</ul></li>
</ol>

<h3><strong>DAY 29: Command-Line Arguments (argc and argv)</strong></h3>

<p><strong>Goal:</strong> Make your program more professional by allowing the user to
specify the data file on the command line.</p>

<p>1. The main function revisited</p>

<p>To accept command-line arguments, you must use a different signature for
main:</p>

<pre><code>int main(int argc, char *argv[])
</code></pre>

<ul>
<li><p>int argc: (Argument Count) An integer holding the number of</p>

<blockquote>
  <p>arguments passed to your program. This is always at least 1,
  because the program's name is the first argument.</p>
</blockquote></li>
<li><p>char *argv[]: (Argument Vector) An array of strings. argv[0] is</p>

<blockquote>
  <p>the program name, argv[1] is the first argument, argv[2] is
  the second, and so on.</p>
</blockquote></li>
</ul>

<p><strong>Example:</strong> If you compile myprogram.c and run ./myprogram hello world,
then:</p>

<ul>
<li><p>argc will be 3.</p></li>
<li><p>argv[0] will be ./myprogram.</p></li>
<li><p>argv[1] will be hello.</p></li>
<li><p>argv[2] will be world.</p></li>
</ul>

<p><strong>2. Day 29 Project Upgrade</strong></p>

<ol>
<li><p><strong>Change main's signature:</strong> In main.c, update int main(void) to</p>

<blockquote>
  <p>int main(int argc, char *argv[]).</p>
</blockquote></li>
<li><p><strong>Determine the Filename:</strong></p>

<ul>
<li><p>Inside main, create a const char *filename variable.</p></li>
<li><p>Check the value of argc. If argc == 2, it means the user</p>

<blockquote>
  <p>provided a filename. Set filename = argv[1];.</p>
</blockquote></li>
<li><p>If argc != 2, the user didn't provide a filename. Set filename</p>

<blockquote>
  <p>to a default value, like "tasks.csv".</p>
</blockquote></li>
</ul></li>
<li><p><strong>Use the Filename:</strong> Pass this filename variable to your load_tasks</p>

<blockquote>
  <p>and save_tasks calls.</p>
</blockquote></li>
<li><p><strong>Compile and Test:</strong></p>

<ul>
<li><pre><code>gcc main.c task.c -o todo_app
</code></pre></li>
<li><p>Run <code>./todo_app</code> (This will use tasks.csv). Add some tasks.</p></li>
<li><p>Run <code>./todo_app school.txt</code>. Add some school-related tasks.</p></li>
<li><p>Check your directory. You should now have two separate to-do</p>

<blockquote>
  <p>list files! You've made your app much more versatile.</p>
</blockquote></li>
</ul></li>
</ol>

    </div>
</body>
</html>
