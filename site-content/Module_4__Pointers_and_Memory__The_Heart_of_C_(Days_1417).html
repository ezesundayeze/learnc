<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4  Pointers and Memory - The Heart of C (Days 14-17)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
        }
        h1, h2 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            margin-bottom: 10px;
        }
        a {
            text-decoration: none;
            color: #0366d6;
            font-size: 1.1em;
        }
        a:hover {
            text-decoration: underline;
        }
        .module-link {
            display: block;
            padding: 10px 15px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        .module-link:hover {
            background-color: #f0f2f5;
            text-decoration: none;
        }
        .bonus-module {
            margin-top: 30px;
            border-top: 2px solid #eee;
            padding-top: 20px;
        }

        .content {
            animation: fadeIn 1s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        body > .content {
            padding: 20px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #f6f8fa;
        }
        pre {
            background-color: #fff;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="content">
        <a href="../index.html">&larr; Back to Home</a>
        <hr>
        <h1>Module 4: Pointers and Memory - The Heart of C (Days 14-17)</h1>

<h2>1. Philosophy Focus: Knowledge Graph &amp; Inductive Teaching</h2>

<p>This is the most important module in the course. Everything in
C---strings, arrays, dynamic memory, and high-performance code---is
built on a deep understanding of pointers. We will connect this new
concept directly to your existing knowledge of variables. The inductive
exercises are designed to make the abstract concept of a "memory
address" feel tangible and concrete.</p>

<h3><strong>DAY 14: What is a Pointer? Memory Addresses</strong></h3>

<p><strong>Goal:</strong> Understand that every variable lives at a specific address in
memory, and a pointer is simply a variable that <em>stores</em> a memory
address.</p>

<p>1. A Mental Model: Your Computer's Memory</p>

<p>Imagine your computer's RAM as a giant street of houses. Each house has
a unique address (like 123 Main St). Each house can store something
inside (like the number 10).</p>

<ul>
<li><p>A regular variable (int x = 10;) is like the <em>contents</em> of the</p>

<blockquote>
  <p>house.</p>
</blockquote></li>
<li><p>A <strong>pointer</strong> is like a piece of paper where you have *written down</p>

<blockquote>
  <p>the address* of that house.</p>
</blockquote></li>
</ul>

<p><strong>Memory Diagram: Visualizing Pointers</strong></p>

<p>Let's make this more concrete. Consider the code <code>int x = 10; int *p = &amp;x;</code>. Here's how you can visualize it in memory:</p>

<p>Two variables are created in the computer's memory. Let's imagine memory as a series of boxes, each with a unique address.</p>

<ul>
<li><p><strong>Variable <code>x</code></strong>:</p>

<ul>
<li>It's an <code>int</code>.</li>
<li>It lives at a memory address, let's say <code>0x7ffc...a1b4</code>.</li>
<li>The value <code>10</code> is stored inside this box.</li>
</ul></li>
<li><p><strong>Variable <code>p</code></strong>:</p>

<ul>
<li>It's an <code>int *</code> (a pointer to an int).</li>
<li>It lives at its own memory address, say <code>0x7ffc...a1b8</code>.</li>
<li>The value stored inside this box is the <strong>address of <code>x</code></strong>, which is <code>0x7ffc...a1b4</code>.</li>
</ul></li>
</ul>

<pre><code>         Variable x                  Variable p
         (type: int)                 (type: int *)
      +----------------+          +----------------+
      |      10        |          | 0x7ffc...a1b4  |
      +----------------+          +----------------+
Address: 0x7ffc...a1b4      Address: 0x7ffc...a1b8
          ^                             |
          |                             |
          +-----------------------------+
</code></pre>

<ul>
<li><code>&amp;x</code> gives you the address of <code>x</code> (<code>0x7ffc...a1b4</code>).</li>
<li><code>p</code> stores this address, so <code>p</code>'s value is <code>0x7ffc...a1b4</code>.</li>
<li><code>*p</code> means "go to the address stored in <code>p</code> and get the value there," which gives you <code>10</code>.</li>
</ul>

<p>This is the core concept. A pointer holds an address, and dereferencing it lets you access the value at that address.</p>

<p><strong>2. Operators: &amp; (address-of) and * (dereference)</strong></p>

<ul>
<li><p>&amp; (The Ampersand): We've seen this with scanf. It's the</p>

<blockquote>
  <p>"address-of" operator. If x is a variable, then &amp;x gives you its
  memory address.</p>
</blockquote></li>
<li><ul>
<li>(The Asterisk): This is the "dereference" or "indirection"
&gt; operator. If p is a pointer that holds an address, then <em>p lets
&gt; you access the value *at that address</em>. It means "go to the
&gt; address stored in this pointer."</li>
</ul></li>

</ul>

3\. Inductive Example:

Let's see this in code. Compile and run:


<pre><code>#include &lt;stdio.h&gt;

int main(void) {
int x = 10; // A regular integer variable.

// 'p' is a POINTER to an integer.
// It's a variable designed to hold the ADDRESS of an int.
int *p;

p = &amp;x; // Store the memory address of 'x' in the pointer 'p'.

printf("Value of x: %d\n", x);
printf("Address of x: %p\n", &amp;x); // %p is for printing addresses
(pointers)
printf("Value of p (it holds the address of x): %p\n", p);

// Now, let's use the pointer to access x's value
printf("Value at the address p points to: %d\n", *p); // Dereference
p

// We can even change x through the pointer!
*p = 25; // "Go to the address stored in p, and put 25 there."
printf("\nAfter changing via pointer, new value of x: %d\n", x);

return 0;
}
</code></pre>


**Memory Diagram: Pass-by-Reference (with Pointers)**

Now, when `actually_increment(&x)` is called, the function's pointer `ptr_num` stores the *address* of `x`.


<pre><code>      main's Scope                   actually_increment's Scope
   +---------------+                +----------------+
x: |      10       |                |  0x...a1b4     | :ptr_num (stores x's address)
   +---------------+                +----------------+
 Address: 0x...a1b4 &lt;----------------------+
                                           |
                                           | *ptr_num = *ptr_num + 1;
                                           |
                                           V
   +---------------+
x: |      11       |  (The value at the original address is changed)
   +---------------+
 Address: 0x...a1b4
</code></pre>


By using `*ptr_num`, the function reaches back to the address it was given and modifies the original value of `x` in `main`.


**4. Discovering the Pattern**

<ul>

<p><li><p><strong>Declaration:</strong> To declare a pointer, you use an asterisk: type</p></p>

<blockquote>
  <p>*pointer<em>name;. For example, int *p</em>int; declares a pointer that
  can hold the address of an int. double *p_double; can hold the
  address of a double.</p>
</blockquote></li>
<li><p><strong>Assignment:</strong> You assign an address to a pointer: p = &x;.</p></li>
<li><p><strong>Usage:</strong> You use the * again to get the value <em>at</em> the address:</p>

<blockquote>
  <p>value = *p;.</p>
</blockquote></li>
</ul>

**5. Day 14 Practice**

<ol>
<li><p>Declare a double variable price and assign it a value.</p></li>
<li><p>Declare a pointer to a double called ptr_price.</p></li>
<li><p>Store the address of price in ptr_price.</p></li>
<li><p>Print the value of price in two ways: once using the price variable</p>

<blockquote>
  <p>directly, and once by dereferencing ptr_price.</p>
</blockquote></li>
<li><p>Change the value of price using only the pointer ptr_price. Print</p>

<blockquote>
  <p>the new value of price to confirm it changed.</p>
</blockquote></li>
</ol>

<h3><strong>DAY 15: Pointers and Functions</strong></h3>

**Goal:** Learn how to use pointers to allow a function to modify
variables from the code that called it.

1\. The Problem: Functions Make Copies

When you pass a regular variable to a function, the function gets a copy
of its value.


<pre><code>#include &lt;stdio.h&gt;

void try_to_increment(int num) {
num = num + 1;
printf("Value inside function: %d\n", num);
}

int main(void) {
int x = 10;
try_to_increment(x);
printf("Value inside main: %d\n", x); // Will this be 10 or 11?
return 0;
}
</code></pre>


Run this. You'll see x is still 10 in main. The function only modified
its local copy.

**Memory Diagram: Pass-by-Value**

When `try_to_increment(x)` is called, the function gets a *copy* of `x`'s value.


<pre><code>      main's Scope                try_to_increment's Scope
   +---------------+             +---------------+
x: |      10       |  ---------&gt;  |      10       | :num (local copy)
   +---------------+             +---------------+
 Address: 0x...a1b4                Address: 0x...c8d0 (different)

                                       |
                                       V
                                   +---------------+
                                   |      11       | :num (after num = num + 1)
                                   +---------------+
</code></pre>

The function's `num` variable lives at a completely different address. Changing `num` has no effect on the original `x` in `main`.

2\. The Solution: Passing a Pointer (the Address)

Instead of passing the value, we can pass the address of the variable.
This allows the function to reach back into main's scope and modify the
original variable. This is called "pass-by-reference."

**Inductive Example:**


<pre><code>#include &lt;stdio.h&gt;

// The parameter is now a POINTER to an integer.
void actually_increment(int *ptr_num) {
// We must dereference the pointer to change the value
// at the address it holds.
*ptr_num = *ptr_num + 1;
}

int main(void) {
int x = 10;

// We must pass the ADDRESS of x using the '&amp;' operator.
actually_increment(&amp;x);

printf("Value inside main is now: %d\n", x); // It's 11!
return 0;
}
</code></pre>


This is the **real reason** scanf needs the &. scanf is a function that
needs to modify your variables, so you must pass it their addresses.

**3. Day 15 Practice**

<ol>
<li><p><strong>Swap Function:</strong> Write a function void swap(int *a, int *b) that</p>

<blockquote>
  <p>takes two integer pointers and swaps the values they point to.</p>
</blockquote>

<p><ul>
<li><p>In main, declare int x = 5; and int y = 10;.</p></li>
<li><p>Call swap(&amp;x, &amp;y);.</p></li>
<li><p>Print x and y after the call to confirm they have been swapped.</p></li>
<li><p>Hint: You'll need a temporary local variable inside your swap</p></p>

<blockquote>
  <p>function. int temp = *a;</p>
</blockquote></li>
</ul></li>
</ol>

<h3><strong>DAY 16: Pointers and Arrays</strong></h3>

**Goal:** Understand the fundamental relationship between arrays and
pointers in C.

1\. The Big Reveal

In C, the name of an array is essentially a pointer to its first
element.

**Inductive Example:**


<pre><code>#include &lt;stdio.h&gt;

int main(void) {
int numbers[4] = {10, 20, 30, 40};

printf("Address of the first element (&amp;numbers[0]): %p\n",
&amp;numbers[0]);
printf("Value of the array name (numbers): %p\n", numbers);

printf("\nThe first element (numbers[0]): %d\n", numbers[0]);
printf("The first element (*numbers): %d\n", *numbers);

return 0;
}
</code></pre>


When you run this, you will see that &numbers[0] and numbers print the
*exact same address*. And numbers[0] and *numbers print the same
value.

**Memory Diagram: Arrays and Pointers**

When you declare `int numbers[4] = {10, 20, 30, 40};`, C allocates a contiguous block of memory for four integers. The variable `numbers` itself acts as a constant pointer to the very beginning of this block.


<pre><code>Let's assume an int is 4 bytes.

              +------+------+------+------+
Memory:       |  10  |  20  |  30  |  40  |
              +------+------+------+------+
Address:      0x1000 0x1004 0x1008 0x100C  &lt;-- Addresses are contiguous
              ^
              |
`numbers` ----+  (value of `numbers` is 0x1000)
`&amp;numbers[0]`-+  (address of the first element is also 0x1000)

`*(numbers)`     is 10
`*(numbers + 1)` is 20 (moves forward by sizeof(int), not 1 byte)
`*(numbers + 2)` is 30
</code></pre>


This is why `numbers[i]` is identical to `*(numbers + i)`. It's all just pointer arithmetic.

2\. Pointer Arithmetic

Because an array name is a pointer, you can do math with it. If you add
1 to a pointer, it doesn't add 1 byte; it moves forward in memory by
the size of the data type it points to.


<pre><code>#include &lt;stdio.h&gt;

int main(void) {
int numbers[4] = {10, 20, 30, 40};
int *p = numbers; // p now points to the first element (10)

printf("First element: %d\n", *(p));
printf("Second element: %d\n", *(p + 1)); // Go to next int's
address
printf("Third element: %d\n", *(p + 2));

// In fact, array access `numbers[i]` is just syntactic sugar for
`*(numbers + i)`.

return 0;
}
</code></pre>


**3. Day 16 Practice**

<ol>
<li><p><strong>Sum an Array:</strong> Write a function int sum_array(int *arr, int</p>

<blockquote>
  <p>size).</p>
</blockquote>

<p><ul>
<li><p>The function should take a pointer to the start of an integer</p></p>

<p><blockquote>
  <p>array and the number of elements in the array.</p>
</blockquote></li>
<li><p>Inside the function, use a for loop to iterate through the array</p></p>

<p><blockquote>
  <p><em>using pointer arithmetic</em>.</p>
</blockquote></li>
<li><p>In each iteration, add the value *(arr + i) to a running total.</p></li>
<li><p>Return the total sum.</p></li>
<li><p>In main, create an array, call this function, and print the</p></p>

<p><blockquote>
  <p>result.</p>
</blockquote></li>
</ul></li>
</ol></p>

<h3><strong>DAY 17: Spaced Repetition - Review</strong></h3>

<p><strong>Goal:</strong> Solidify your understanding of pointers by using them in a
practical function.</p>

<p>1. Done-for-you Training Plan: Find Min and Max</p>

<p>Write a function that finds both the minimum and maximum values in an
array in a single pass. This is a common problem that perfectly
demonstrates the power of passing pointers as function arguments.</p>

<p><strong>Project Requirements:</strong></p>

<ol>
<li><p>Define a function with the following signature:</p>

<blockquote>
  <p>void find<em>min</em>max(int *arr, int size, int *out<em>min, int
  *out</em>max)</p>
</blockquote></li>
<li><p><strong>Parameters:</strong></p>

<ul>
<li><p>int *arr: A pointer to the beginning of an integer array.</p></li>
<li><p>int size: The number of elements in the array.</p></li>
<li><p>int *out_min: A pointer to an integer variable in the calling</p>

<blockquote>
  <p>function. Your function will write the minimum value to this
  address.</p>
</blockquote></li>
<li><p>int *out_max: A pointer to an integer variable where you'll</p>

<blockquote>
  <p>write the maximum value.</p>
</blockquote></li>
</ul></li>
<li><p><strong>Implementation:</strong></p>

<ul>
<li><p>Inside the function, assume the first element is both the min</p>

<blockquote>
  <p>and the max. *out<em>min = arr[0]; and *out</em>max = arr[0];.</p>
</blockquote></li>
<li><p>Loop through the rest of the array (from the second element to</p>

<blockquote>
  <p>the end).</p>
</blockquote></li>
<li><p>In each iteration, if you find a smaller number, update the</p>

<blockquote>
  <p>value at out<em>min (*out</em>min = ...).</p>
</blockquote></li>
<li><p>If you find a larger number, update the value at out_max.</p></li>
</ul></li>
<li><p><strong>In main:</strong></p>

<ul>
<li><p>Create an integer array, e.g., {5, 2, 9, 1, 8}.</p></li>
<li><p>Declare two regular integer variables, min<em>val and max</em>val.</p></li>
<li><p>Call your function, passing the array, its size, and the</p>

<blockquote>
  <p><strong>addresses</strong> of your min/max variables:
  find<em>min</em>max(my<em>array, 5, &amp;min</em>val, &amp;max_val);.</p>
</blockquote></li>
<li><p>After the function returns, print the values of min_val and</p>

<blockquote>
  <p>max_val. They should be 1 and 9.</p>
</blockquote></li>
</ul></li>
</ol>

<hr />

<h3><strong>DAY 17+: Common Pitfalls &amp; Debugging</strong></h3>

<p>Pointers are powerful, but they are also a common source of bugs. Here are some of the most frequent mistakes and how to handle them.</p>

<p><strong>1. The Uninitialized Pointer</strong></p>

<p>A pointer that has been declared but doesn't point to a valid memory address is <strong>uninitialized</strong>. It holds a garbage value. Trying to use it will cause a crash or unpredictable behavior.</p>

<pre><code>int *p; // p is uninitialized. It points to a random, invalid address.
*p = 50; // CRASH! You are writing to a random place in memory.
</code></pre>

<p><strong>Rule:</strong> Always initialize your pointers. If you don't have a valid address to assign yet, initialize it to <code>NULL</code>.</p>

<pre><code>int *p = NULL; // Good practice.
</code></pre>

<p><strong>2. The NULL Pointer Dereference</strong></p>

<p>This is one of the most common C errors. It means you are trying to access the value at address <code>0</code>, which is always invalid. This will cause a "Segmentation Fault" or similar crash.</p>

<pre><code>int *p = NULL;
printf("%d\n", *p); // CRASH! Cannot dereference a NULL pointer.
</code></pre>

<p><strong>Rule:</strong> Always check if a pointer is <code>NULL</code> before you dereference it, especially if it's coming from a function that might fail (like <code>malloc</code>, which we'll see later).</p>

<pre><code>if (p != NULL) {
    // It's safe to use p now
    printf("%d\n", *p);
}
</code></pre>

<p><strong>3. Forgetting the <code>&amp;</code></strong></p>

<p>When you want a function to change your variable (like with <code>scanf</code> or the <code>swap</code> function you wrote), you <em>must</em> pass its address. Forgetting the <code>&amp;</code> is a very common mistake.</p>

<pre><code>int x = 10;
// WRONG: scanf("%d", x);  -- This passes the value 10, not the address.
// RIGHT: scanf("%d", &amp;x); -- This passes the address where x lives.
</code></pre>

<p><strong>Simple Debugging Tip: "printf" Debugging</strong></p>

<p>If your program is crashing and you suspect a bad pointer, the simplest debugging technique is to print the pointer's value (its address) and the value it points to at different stages.</p>

<pre><code>int x = 10;
int *p = &amp;x;

printf("Address of x is %p\n", &amp;x);
printf("Pointer p holds the address %p\n", p);

if (p != NULL) {
    printf("The value at address %p is %d\n", p, *p);
} else {
    printf("Pointer p is NULL.\n");
}
</code></pre>

<p>By printing the state of your variables, you can often trace exactly where a pointer becomes invalid.</p>

    </div>
</body>
</html>
